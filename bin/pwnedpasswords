#!/usr/bin/env python3
# vim: ft=python

from subprocess import call
import argparse
import os
import sys
import pprint
from pwnedpasswords import Password
import logging
import math

class PwnedPasswordsCommandLineHandler(object):
    def __init__(self, namespace):
        verbosity = logging.DEBUG if namespace.verbose else logging.WARNING
        self.password = Password(namespace.password[0], namespace.original_password_is_hash, verbosity=verbosity)

    def run(self, *args):
        value = self.password.check()
        print(value)
        if value > 0:
            # Most systems require exit status to be in the range 0-127, so
            # return the base-10 log of the number of entries instead of the
            # full number of entries.
            sys.exit(int(math.log10(value)))
        else:
            sys.exit(None)

def BoolAction(true_choice):
    class Action(argparse.Action):
        def __call__(self, parser, namespace, values, option_string=None):
            setattr(namespace, self.dest, option_string == true_choice)

    return Action

if __name__ == "__main__":
    parser = argparse.ArgumentParser(prog='pwnedpasswords')
    parser.add_argument("password", type=str, nargs=1, help="The password or hashed password to search for.")
    parser.add_argument("--original-password-is-hash", nargs=0, action=BoolAction("--original-password-is-a-hash"), dest="original_password_is_hash", default=False, help="Searches for a password which was originally a SHA-1 hash, causing it to be hashed again before being compared to the Pwned Password repository.")
    parser.add_argument("--verbose", nargs=0, action=BoolAction("--verbose"), dest="verbose", default=False, help="Display verbose output.")

    namespace = parser.parse_args()
    handler = PwnedPasswordsCommandLineHandler(namespace)
    handler.run()

